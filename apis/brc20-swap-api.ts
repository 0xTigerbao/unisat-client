/* tslint:disable */
/* eslint-disable */
/**
 * UniSat Wallet - OpenAPI
 * This is UniSat Wallet Open API. If you wish to use the OpenAPI, please feel free to send us an email, and we will provide you with an API KEY.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: contact@unisat.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { Brc20swapAddLiqBody } from '../models';
import { Brc20swapConfirmCancelWithdrawBody } from '../models';
import { Brc20swapConfirmDepositBody } from '../models';
import { Brc20swapConfirmWithdrawBody } from '../models';
import { Brc20swapDeployPoolBody } from '../models';
import { Brc20swapRemoveLiqBody } from '../models';
import { Brc20swapSwapBody } from '../models';
import { InlineResponse20023 } from '../models';
import { InlineResponse20024 } from '../models';
import { InlineResponse20025 } from '../models';
import { InlineResponse20026 } from '../models';
import { InlineResponse20027 } from '../models';
import { InlineResponse20028 } from '../models';
import { InlineResponse20029 } from '../models';
import { InlineResponse20030 } from '../models';
import { InlineResponse20031 } from '../models';
import { InlineResponse20032 } from '../models';
import { InlineResponse20033 } from '../models';
import { InlineResponse20034 } from '../models';
import { InlineResponse20035 } from '../models';
import { InlineResponse20036 } from '../models';
import { InlineResponse20037 } from '../models';
import { InlineResponse20038 } from '../models';
import { InlineResponse20039 } from '../models';
import { InlineResponse20040 } from '../models';
import { InlineResponse20041 } from '../models';
import { InlineResponse20042 } from '../models';
import { InlineResponse20043 } from '../models';
import { InlineResponse20044 } from '../models';
import { InlineResponse20045 } from '../models';
import { InlineResponse20046 } from '../models';
import { InlineResponse20047 } from '../models';
import { InlineResponse20048 } from '../models';
/**
 * BRC20SwapApi - axios parameter creator
 * @export
 */
export const BRC20SwapApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add the liquidity operation.
         * @param {Brc20swapAddLiqBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapAddLiqPost: async (body: Brc20swapAddLiqBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v1Brc20SwapAddLiqPost.');
            }
            const localVarPath = `/v1/brc20-swap/add_liq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the balance for the specified address and tick.
         * @param {string} address 
         * @param {string} tick 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapBalanceGet: async (address: string, tick: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapBalanceGet.');
            }
            // verify required parameter 'tick' is not null or undefined
            if (tick === null || tick === undefined) {
                throw new RequiredError('tick','Required parameter tick was null or undefined when calling v1Brc20SwapBalanceGet.');
            }
            const localVarPath = `/v1/brc20-swap/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick !== undefined) {
                localVarQueryParameter['tick'] = tick;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Swap's global configuration information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/brc20-swap/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User signature cancel-withdraw psbt, submit confirmation.
         * @param {Brc20swapConfirmCancelWithdrawBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapConfirmCancelWithdrawPost: async (body: Brc20swapConfirmCancelWithdrawBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v1Brc20SwapConfirmCancelWithdrawPost.');
            }
            const localVarPath = `/v1/brc20-swap/confirm_cancel_withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User signature deposit psbt, submit confirmation.
         * @param {Brc20swapConfirmDepositBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapConfirmDepositPost: async (body: Brc20swapConfirmDepositBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v1Brc20SwapConfirmDepositPost.');
            }
            const localVarPath = `/v1/brc20-swap/confirm_deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User signature withdraw psbt, submit confirmation.
         * @param {Brc20swapConfirmWithdrawBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapConfirmWithdrawPost: async (body: Brc20swapConfirmWithdrawBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v1Brc20SwapConfirmWithdrawPost.');
            }
            const localVarPath = `/v1/brc20-swap/confirm_withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a cancel-withdraw psbt to be signed by the user.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapCreateCancelWithdrawGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v1Brc20SwapCreateCancelWithdrawGet.');
            }
            const localVarPath = `/v1/brc20-swap/create_cancel_withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a deposit psbt to be signed by the user.
         * @param {string} inscriptionId 
         * @param {string} pubkey 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapCreateDepositGet: async (inscriptionId: string, pubkey: string, address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inscriptionId' is not null or undefined
            if (inscriptionId === null || inscriptionId === undefined) {
                throw new RequiredError('inscriptionId','Required parameter inscriptionId was null or undefined when calling v1Brc20SwapCreateDepositGet.');
            }
            // verify required parameter 'pubkey' is not null or undefined
            if (pubkey === null || pubkey === undefined) {
                throw new RequiredError('pubkey','Required parameter pubkey was null or undefined when calling v1Brc20SwapCreateDepositGet.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapCreateDepositGet.');
            }
            const localVarPath = `/v1/brc20-swap/create_deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (inscriptionId !== undefined) {
                localVarQueryParameter['inscriptionId'] = inscriptionId;
            }

            if (pubkey !== undefined) {
                localVarQueryParameter['pubkey'] = pubkey;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a withdraw psbt to be signed by the user.
         * @param {string} pubkey 
         * @param {string} address 
         * @param {string} tick 
         * @param {string} amount 
         * @param {number} ts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapCreateWithdrawGet: async (pubkey: string, address: string, tick: string, amount: string, ts: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            if (pubkey === null || pubkey === undefined) {
                throw new RequiredError('pubkey','Required parameter pubkey was null or undefined when calling v1Brc20SwapCreateWithdrawGet.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapCreateWithdrawGet.');
            }
            // verify required parameter 'tick' is not null or undefined
            if (tick === null || tick === undefined) {
                throw new RequiredError('tick','Required parameter tick was null or undefined when calling v1Brc20SwapCreateWithdrawGet.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling v1Brc20SwapCreateWithdrawGet.');
            }
            // verify required parameter 'ts' is not null or undefined
            if (ts === null || ts === undefined) {
                throw new RequiredError('ts','Required parameter ts was null or undefined when calling v1Brc20SwapCreateWithdrawGet.');
            }
            const localVarPath = `/v1/brc20-swap/create_withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (pubkey !== undefined) {
                localVarQueryParameter['pubkey'] = pubkey;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick !== undefined) {
                localVarQueryParameter['tick'] = tick;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deploy the pool operation.
         * @param {Brc20swapDeployPoolBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapDeployPoolPost: async (body: Brc20swapDeployPoolBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v1Brc20SwapDeployPoolPost.');
            }
            const localVarPath = `/v1/brc20-swap/deploy_pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get deposit information for the specified address and tick, including daily limit, dosage, recommended deposit amount, etc.
         * @param {string} address 
         * @param {string} tick 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapDepositInfoGet: async (address: string, tick: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapDepositInfoGet.');
            }
            // verify required parameter 'tick' is not null or undefined
            if (tick === null || tick === undefined) {
                throw new RequiredError('tick','Required parameter tick was null or undefined when calling v1Brc20SwapDepositInfoGet.');
            }
            const localVarPath = `/v1/brc20-swap/deposit_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick !== undefined) {
                localVarQueryParameter['tick'] = tick;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the deposit list for a user.
         * @param {string} address 
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [tick] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapDepositListGet: async (address: string, start: number, limit: number, tick?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapDepositListGet.');
            }
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling v1Brc20SwapDepositListGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v1Brc20SwapDepositListGet.');
            }
            const localVarPath = `/v1/brc20-swap/deposit_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick !== undefined) {
                localVarQueryParameter['tick'] = tick;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the gas consumption records for a user aggregation operation.
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [address] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapGasHistoryGet: async (start: number, limit: number, address?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling v1Brc20SwapGasHistoryGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v1Brc20SwapGasHistoryGet.');
            }
            const localVarPath = `/v1/brc20-swap/gas_history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the history of a pair addition pool.
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [address] 
         * @param {string} [tick] 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapLiqHistoryGet: async (start: number, limit: number, address?: string, tick?: string, type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling v1Brc20SwapLiqHistoryGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v1Brc20SwapLiqHistoryGet.');
            }
            const localVarPath = `/v1/brc20-swap/liq_history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick !== undefined) {
                localVarQueryParameter['tick'] = tick;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the user pool information for the specified pair.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapMyPoolGet: async (address: string, tick0: string, tick1: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapMyPoolGet.');
            }
            // verify required parameter 'tick0' is not null or undefined
            if (tick0 === null || tick0 === undefined) {
                throw new RequiredError('tick0','Required parameter tick0 was null or undefined when calling v1Brc20SwapMyPoolGet.');
            }
            // verify required parameter 'tick1' is not null or undefined
            if (tick1 === null || tick1 === undefined) {
                throw new RequiredError('tick1','Required parameter tick1 was null or undefined when calling v1Brc20SwapMyPoolGet.');
            }
            const localVarPath = `/v1/brc20-swap/my_pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick0 !== undefined) {
                localVarQueryParameter['tick0'] = tick0;
            }

            if (tick1 !== undefined) {
                localVarQueryParameter['tick1'] = tick1;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the pool list information by address.
         * @param {string} address 
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [tick] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapMyPoolListGet: async (address: string, start: number, limit: number, tick?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapMyPoolListGet.');
            }
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling v1Brc20SwapMyPoolListGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v1Brc20SwapMyPoolListGet.');
            }
            const localVarPath = `/v1/brc20-swap/my_pool_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick !== undefined) {
                localVarQueryParameter['tick'] = tick;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary An overview of swap information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapOverviewGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/brc20-swap/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the pool list information.
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [search] Fuzzy matching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapPoolListGet: async (start: number, limit: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling v1Brc20SwapPoolListGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v1Brc20SwapPoolListGet.');
            }
            const localVarPath = `/v1/brc20-swap/pool_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /add_liq interface pre-load, get the signature content, gas and byte information.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {string} amount0 Input amount of tick0
         * @param {string} amount1 Input amount of tick1
         * @param {string} lp Expect amount of lp
         * @param {string} slippage 
         * @param {number} ts Timestamp (seconds)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapPreAddLiqGet: async (address: string, tick0: string, tick1: string, amount0: string, amount1: string, lp: string, slippage: string, ts: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapPreAddLiqGet.');
            }
            // verify required parameter 'tick0' is not null or undefined
            if (tick0 === null || tick0 === undefined) {
                throw new RequiredError('tick0','Required parameter tick0 was null or undefined when calling v1Brc20SwapPreAddLiqGet.');
            }
            // verify required parameter 'tick1' is not null or undefined
            if (tick1 === null || tick1 === undefined) {
                throw new RequiredError('tick1','Required parameter tick1 was null or undefined when calling v1Brc20SwapPreAddLiqGet.');
            }
            // verify required parameter 'amount0' is not null or undefined
            if (amount0 === null || amount0 === undefined) {
                throw new RequiredError('amount0','Required parameter amount0 was null or undefined when calling v1Brc20SwapPreAddLiqGet.');
            }
            // verify required parameter 'amount1' is not null or undefined
            if (amount1 === null || amount1 === undefined) {
                throw new RequiredError('amount1','Required parameter amount1 was null or undefined when calling v1Brc20SwapPreAddLiqGet.');
            }
            // verify required parameter 'lp' is not null or undefined
            if (lp === null || lp === undefined) {
                throw new RequiredError('lp','Required parameter lp was null or undefined when calling v1Brc20SwapPreAddLiqGet.');
            }
            // verify required parameter 'slippage' is not null or undefined
            if (slippage === null || slippage === undefined) {
                throw new RequiredError('slippage','Required parameter slippage was null or undefined when calling v1Brc20SwapPreAddLiqGet.');
            }
            // verify required parameter 'ts' is not null or undefined
            if (ts === null || ts === undefined) {
                throw new RequiredError('ts','Required parameter ts was null or undefined when calling v1Brc20SwapPreAddLiqGet.');
            }
            const localVarPath = `/v1/brc20-swap/pre_add_liq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick0 !== undefined) {
                localVarQueryParameter['tick0'] = tick0;
            }

            if (tick1 !== undefined) {
                localVarQueryParameter['tick1'] = tick1;
            }

            if (amount0 !== undefined) {
                localVarQueryParameter['amount0'] = amount0;
            }

            if (amount1 !== undefined) {
                localVarQueryParameter['amount1'] = amount1;
            }

            if (lp !== undefined) {
                localVarQueryParameter['lp'] = lp;
            }

            if (slippage !== undefined) {
                localVarQueryParameter['slippage'] = slippage;
            }

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /deploy_pool interface pre-load, get the signature content, gas and byte information.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {number} ts Timestamp (seconds)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapPreDeployPoolGet: async (address: string, tick0: string, tick1: string, ts: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapPreDeployPoolGet.');
            }
            // verify required parameter 'tick0' is not null or undefined
            if (tick0 === null || tick0 === undefined) {
                throw new RequiredError('tick0','Required parameter tick0 was null or undefined when calling v1Brc20SwapPreDeployPoolGet.');
            }
            // verify required parameter 'tick1' is not null or undefined
            if (tick1 === null || tick1 === undefined) {
                throw new RequiredError('tick1','Required parameter tick1 was null or undefined when calling v1Brc20SwapPreDeployPoolGet.');
            }
            // verify required parameter 'ts' is not null or undefined
            if (ts === null || ts === undefined) {
                throw new RequiredError('ts','Required parameter ts was null or undefined when calling v1Brc20SwapPreDeployPoolGet.');
            }
            const localVarPath = `/v1/brc20-swap/pre_deploy_pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick0 !== undefined) {
                localVarQueryParameter['tick0'] = tick0;
            }

            if (tick1 !== undefined) {
                localVarQueryParameter['tick1'] = tick1;
            }

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /remove_liq interface pre-load, get the signature content, gas and byte information.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {string} amount0 Input amount of tick0
         * @param {string} amount1 Input amount of tick1
         * @param {string} lp 
         * @param {string} slippage 
         * @param {number} ts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapPreRemoveLiqGet: async (address: string, tick0: string, tick1: string, amount0: string, amount1: string, lp: string, slippage: string, ts: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapPreRemoveLiqGet.');
            }
            // verify required parameter 'tick0' is not null or undefined
            if (tick0 === null || tick0 === undefined) {
                throw new RequiredError('tick0','Required parameter tick0 was null or undefined when calling v1Brc20SwapPreRemoveLiqGet.');
            }
            // verify required parameter 'tick1' is not null or undefined
            if (tick1 === null || tick1 === undefined) {
                throw new RequiredError('tick1','Required parameter tick1 was null or undefined when calling v1Brc20SwapPreRemoveLiqGet.');
            }
            // verify required parameter 'amount0' is not null or undefined
            if (amount0 === null || amount0 === undefined) {
                throw new RequiredError('amount0','Required parameter amount0 was null or undefined when calling v1Brc20SwapPreRemoveLiqGet.');
            }
            // verify required parameter 'amount1' is not null or undefined
            if (amount1 === null || amount1 === undefined) {
                throw new RequiredError('amount1','Required parameter amount1 was null or undefined when calling v1Brc20SwapPreRemoveLiqGet.');
            }
            // verify required parameter 'lp' is not null or undefined
            if (lp === null || lp === undefined) {
                throw new RequiredError('lp','Required parameter lp was null or undefined when calling v1Brc20SwapPreRemoveLiqGet.');
            }
            // verify required parameter 'slippage' is not null or undefined
            if (slippage === null || slippage === undefined) {
                throw new RequiredError('slippage','Required parameter slippage was null or undefined when calling v1Brc20SwapPreRemoveLiqGet.');
            }
            // verify required parameter 'ts' is not null or undefined
            if (ts === null || ts === undefined) {
                throw new RequiredError('ts','Required parameter ts was null or undefined when calling v1Brc20SwapPreRemoveLiqGet.');
            }
            const localVarPath = `/v1/brc20-swap/pre_remove_liq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick0 !== undefined) {
                localVarQueryParameter['tick0'] = tick0;
            }

            if (tick1 !== undefined) {
                localVarQueryParameter['tick1'] = tick1;
            }

            if (amount0 !== undefined) {
                localVarQueryParameter['amount0'] = amount0;
            }

            if (amount1 !== undefined) {
                localVarQueryParameter['amount1'] = amount1;
            }

            if (lp !== undefined) {
                localVarQueryParameter['lp'] = lp;
            }

            if (slippage !== undefined) {
                localVarQueryParameter['slippage'] = slippage;
            }

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /swap interface pre-load, get the signature content, gas and byte information.
         * @param {string} address 
         * @param {string} tickIn Input tick
         * @param {string} tickOut Output tick
         * @param {string} amountIn The amount of input tick
         * @param {string} amountOut The amount of output tick
         * @param {string} slippage 
         * @param {string} exactType 
         * @param {number} ts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapPreSwapGet: async (address: string, tickIn: string, tickOut: string, amountIn: string, amountOut: string, slippage: string, exactType: string, ts: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapPreSwapGet.');
            }
            // verify required parameter 'tickIn' is not null or undefined
            if (tickIn === null || tickIn === undefined) {
                throw new RequiredError('tickIn','Required parameter tickIn was null or undefined when calling v1Brc20SwapPreSwapGet.');
            }
            // verify required parameter 'tickOut' is not null or undefined
            if (tickOut === null || tickOut === undefined) {
                throw new RequiredError('tickOut','Required parameter tickOut was null or undefined when calling v1Brc20SwapPreSwapGet.');
            }
            // verify required parameter 'amountIn' is not null or undefined
            if (amountIn === null || amountIn === undefined) {
                throw new RequiredError('amountIn','Required parameter amountIn was null or undefined when calling v1Brc20SwapPreSwapGet.');
            }
            // verify required parameter 'amountOut' is not null or undefined
            if (amountOut === null || amountOut === undefined) {
                throw new RequiredError('amountOut','Required parameter amountOut was null or undefined when calling v1Brc20SwapPreSwapGet.');
            }
            // verify required parameter 'slippage' is not null or undefined
            if (slippage === null || slippage === undefined) {
                throw new RequiredError('slippage','Required parameter slippage was null or undefined when calling v1Brc20SwapPreSwapGet.');
            }
            // verify required parameter 'exactType' is not null or undefined
            if (exactType === null || exactType === undefined) {
                throw new RequiredError('exactType','Required parameter exactType was null or undefined when calling v1Brc20SwapPreSwapGet.');
            }
            // verify required parameter 'ts' is not null or undefined
            if (ts === null || ts === undefined) {
                throw new RequiredError('ts','Required parameter ts was null or undefined when calling v1Brc20SwapPreSwapGet.');
            }
            const localVarPath = `/v1/brc20-swap/pre_swap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tickIn !== undefined) {
                localVarQueryParameter['tickIn'] = tickIn;
            }

            if (tickOut !== undefined) {
                localVarQueryParameter['tickOut'] = tickOut;
            }

            if (amountIn !== undefined) {
                localVarQueryParameter['amountIn'] = amountIn;
            }

            if (amountOut !== undefined) {
                localVarQueryParameter['amountOut'] = amountOut;
            }

            if (slippage !== undefined) {
                localVarQueryParameter['slippage'] = slippage;
            }

            if (exactType !== undefined) {
                localVarQueryParameter['exactType'] = exactType;
            }

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Based on the pair to get the actual addition ratio, LP number and other information.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {string} [amount0] amount0 and amount1 can only be set individually.
         * @param {string} [amount1] amount0 and amount1 can only be set individually.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapQuoteAddLiqGet: async (address: string, tick0: string, tick1: string, amount0?: string, amount1?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapQuoteAddLiqGet.');
            }
            // verify required parameter 'tick0' is not null or undefined
            if (tick0 === null || tick0 === undefined) {
                throw new RequiredError('tick0','Required parameter tick0 was null or undefined when calling v1Brc20SwapQuoteAddLiqGet.');
            }
            // verify required parameter 'tick1' is not null or undefined
            if (tick1 === null || tick1 === undefined) {
                throw new RequiredError('tick1','Required parameter tick1 was null or undefined when calling v1Brc20SwapQuoteAddLiqGet.');
            }
            const localVarPath = `/v1/brc20-swap/quote_add_liq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick0 !== undefined) {
                localVarQueryParameter['tick0'] = tick0;
            }

            if (tick1 !== undefined) {
                localVarQueryParameter['tick1'] = tick1;
            }

            if (amount0 !== undefined) {
                localVarQueryParameter['amount0'] = amount0;
            }

            if (amount1 !== undefined) {
                localVarQueryParameter['amount1'] = amount1;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Estimate the number of ticks you can get by typing LP.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {string} lp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapQuoteRemoveLiqGet: async (address: string, tick0: string, tick1: string, lp: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapQuoteRemoveLiqGet.');
            }
            // verify required parameter 'tick0' is not null or undefined
            if (tick0 === null || tick0 === undefined) {
                throw new RequiredError('tick0','Required parameter tick0 was null or undefined when calling v1Brc20SwapQuoteRemoveLiqGet.');
            }
            // verify required parameter 'tick1' is not null or undefined
            if (tick1 === null || tick1 === undefined) {
                throw new RequiredError('tick1','Required parameter tick1 was null or undefined when calling v1Brc20SwapQuoteRemoveLiqGet.');
            }
            // verify required parameter 'lp' is not null or undefined
            if (lp === null || lp === undefined) {
                throw new RequiredError('lp','Required parameter lp was null or undefined when calling v1Brc20SwapQuoteRemoveLiqGet.');
            }
            const localVarPath = `/v1/brc20-swap/quote_remove_liq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick0 !== undefined) {
                localVarQueryParameter['tick0'] = tick0;
            }

            if (tick1 !== undefined) {
                localVarQueryParameter['tick1'] = tick1;
            }

            if (lp !== undefined) {
                localVarQueryParameter['lp'] = lp;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary quote swap
         * @param {string} address 
         * @param {string} tickIn Input tick
         * @param {string} tickOut Output tick
         * @param {string} amount The amount of input tick
         * @param {string} exactType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapQuoteSwapGet: async (address: string, tickIn: string, tickOut: string, amount: string, exactType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapQuoteSwapGet.');
            }
            // verify required parameter 'tickIn' is not null or undefined
            if (tickIn === null || tickIn === undefined) {
                throw new RequiredError('tickIn','Required parameter tickIn was null or undefined when calling v1Brc20SwapQuoteSwapGet.');
            }
            // verify required parameter 'tickOut' is not null or undefined
            if (tickOut === null || tickOut === undefined) {
                throw new RequiredError('tickOut','Required parameter tickOut was null or undefined when calling v1Brc20SwapQuoteSwapGet.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling v1Brc20SwapQuoteSwapGet.');
            }
            // verify required parameter 'exactType' is not null or undefined
            if (exactType === null || exactType === undefined) {
                throw new RequiredError('exactType','Required parameter exactType was null or undefined when calling v1Brc20SwapQuoteSwapGet.');
            }
            const localVarPath = `/v1/brc20-swap/quote_swap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tickIn !== undefined) {
                localVarQueryParameter['tickIn'] = tickIn;
            }

            if (tickOut !== undefined) {
                localVarQueryParameter['tickOut'] = tickOut;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (exactType !== undefined) {
                localVarQueryParameter['exactType'] = exactType;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the liquidity operation
         * @param {Brc20swapRemoveLiqBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapRemoveLiqPost: async (body: Brc20swapRemoveLiqBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v1Brc20SwapRemoveLiqPost.');
            }
            const localVarPath = `/v1/brc20-swap/remove_liq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get chain history of rollup inscription.
         * @param {number} start 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapRollupHistoryGet: async (start: number, limit: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling v1Brc20SwapRollupHistoryGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v1Brc20SwapRollupHistoryGet.');
            }
            const localVarPath = `/v1/brc20-swap/rollup_history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Select the tick information that you can use based on the address.
         * @param {string} address 
         * @param {string} [search] Fuzzy matching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapSelectGet: async (address: string, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapSelectGet.');
            }
            const localVarPath = `/v1/brc20-swap/select`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the history of swap.
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [address] 
         * @param {string} [tick] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapSwapHistoryGet: async (start: number, limit: number, address?: string, tick?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling v1Brc20SwapSwapHistoryGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v1Brc20SwapSwapHistoryGet.');
            }
            const localVarPath = `/v1/brc20-swap/swap_history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (tick !== undefined) {
                localVarQueryParameter['tick'] = tick;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The swap operation.
         * @param {Brc20swapSwapBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapSwapPost: async (body: Brc20swapSwapBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v1Brc20SwapSwapPost.');
            }
            const localVarPath = `/v1/brc20-swap/swap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the current system state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapSystemStatusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/brc20-swap/system_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the user withdrawal history.
         * @param {string} address 
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [tick] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapWithdrawHistoryGet: async (address: string, start: number, limit: number, tick?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling v1Brc20SwapWithdrawHistoryGet.');
            }
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling v1Brc20SwapWithdrawHistoryGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v1Brc20SwapWithdrawHistoryGet.');
            }
            const localVarPath = `/v1/brc20-swap/withdraw_history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tick !== undefined) {
                localVarQueryParameter['tick'] = tick;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the withdrawal progress for the specified ID.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1Brc20SwapWithdrawProcessGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v1Brc20SwapWithdrawProcessGet.');
            }
            const localVarPath = `/v1/brc20-swap/withdraw_process`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BRC20SwapApi - functional programming interface
 * @export
 */
export const BRC20SwapApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add the liquidity operation.
         * @param {Brc20swapAddLiqBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapAddLiqPost(body: Brc20swapAddLiqBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20030>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapAddLiqPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the balance for the specified address and tick.
         * @param {string} address 
         * @param {string} tick 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapBalanceGet(address: string, tick: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20024>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapBalanceGet(address, tick, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Swap's global configuration information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20023>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapConfigGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary User signature cancel-withdraw psbt, submit confirmation.
         * @param {Brc20swapConfirmCancelWithdrawBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapConfirmCancelWithdrawPost(body: Brc20swapConfirmCancelWithdrawBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20028>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapConfirmCancelWithdrawPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary User signature deposit psbt, submit confirmation.
         * @param {Brc20swapConfirmDepositBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapConfirmDepositPost(body: Brc20swapConfirmDepositBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20028>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapConfirmDepositPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary User signature withdraw psbt, submit confirmation.
         * @param {Brc20swapConfirmWithdrawBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapConfirmWithdrawPost(body: Brc20swapConfirmWithdrawBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20028>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapConfirmWithdrawPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a cancel-withdraw psbt to be signed by the user.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapCreateCancelWithdrawGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20047>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapCreateCancelWithdrawGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a deposit psbt to be signed by the user.
         * @param {string} inscriptionId 
         * @param {string} pubkey 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapCreateDepositGet(inscriptionId: string, pubkey: string, address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20043>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapCreateDepositGet(inscriptionId, pubkey, address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a withdraw psbt to be signed by the user.
         * @param {string} pubkey 
         * @param {string} address 
         * @param {string} tick 
         * @param {string} amount 
         * @param {number} ts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapCreateWithdrawGet(pubkey: string, address: string, tick: string, amount: string, ts: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20046>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapCreateWithdrawGet(pubkey, address, tick, amount, ts, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deploy the pool operation.
         * @param {Brc20swapDeployPoolBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapDeployPoolPost(body: Brc20swapDeployPoolBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20028>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapDeployPoolPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get deposit information for the specified address and tick, including daily limit, dosage, recommended deposit amount, etc.
         * @param {string} address 
         * @param {string} tick 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapDepositInfoGet(address: string, tick: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20025>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapDepositInfoGet(address, tick, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the deposit list for a user.
         * @param {string} address 
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [tick] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapDepositListGet(address: string, start: number, limit: number, tick?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20042>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapDepositListGet(address, start, limit, tick, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the gas consumption records for a user aggregation operation.
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [address] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapGasHistoryGet(start: number, limit: number, address?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20038>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapGasHistoryGet(start, limit, address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the history of a pair addition pool.
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [address] 
         * @param {string} [tick] 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapLiqHistoryGet(start: number, limit: number, address?: string, tick?: string, type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20039>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapLiqHistoryGet(start, limit, address, tick, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the user pool information for the specified pair.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapMyPoolGet(address: string, tick0: string, tick1: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20036>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapMyPoolGet(address, tick0, tick1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the pool list information by address.
         * @param {string} address 
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [tick] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapMyPoolListGet(address: string, start: number, limit: number, tick?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20035>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapMyPoolListGet(address, start, limit, tick, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary An overview of swap information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapOverviewGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20037>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapOverviewGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the pool list information.
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [search] Fuzzy matching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapPoolListGet(start: number, limit: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20034>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapPoolListGet(start, limit, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /add_liq interface pre-load, get the signature content, gas and byte information.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {string} amount0 Input amount of tick0
         * @param {string} amount1 Input amount of tick1
         * @param {string} lp Expect amount of lp
         * @param {string} slippage 
         * @param {number} ts Timestamp (seconds)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapPreAddLiqGet(address: string, tick0: string, tick1: string, amount0: string, amount1: string, lp: string, slippage: string, ts: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20027>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapPreAddLiqGet(address, tick0, tick1, amount0, amount1, lp, slippage, ts, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /deploy_pool interface pre-load, get the signature content, gas and byte information.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {number} ts Timestamp (seconds)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapPreDeployPoolGet(address: string, tick0: string, tick1: string, ts: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20027>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapPreDeployPoolGet(address, tick0, tick1, ts, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /remove_liq interface pre-load, get the signature content, gas and byte information.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {string} amount0 Input amount of tick0
         * @param {string} amount1 Input amount of tick1
         * @param {string} lp 
         * @param {string} slippage 
         * @param {number} ts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapPreRemoveLiqGet(address: string, tick0: string, tick1: string, amount0: string, amount1: string, lp: string, slippage: string, ts: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20027>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapPreRemoveLiqGet(address, tick0, tick1, amount0, amount1, lp, slippage, ts, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /swap interface pre-load, get the signature content, gas and byte information.
         * @param {string} address 
         * @param {string} tickIn Input tick
         * @param {string} tickOut Output tick
         * @param {string} amountIn The amount of input tick
         * @param {string} amountOut The amount of output tick
         * @param {string} slippage 
         * @param {string} exactType 
         * @param {number} ts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapPreSwapGet(address: string, tickIn: string, tickOut: string, amountIn: string, amountOut: string, slippage: string, exactType: string, ts: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20027>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapPreSwapGet(address, tickIn, tickOut, amountIn, amountOut, slippage, exactType, ts, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Based on the pair to get the actual addition ratio, LP number and other information.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {string} [amount0] amount0 and amount1 can only be set individually.
         * @param {string} [amount1] amount0 and amount1 can only be set individually.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapQuoteAddLiqGet(address: string, tick0: string, tick1: string, amount0?: string, amount1?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20029>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapQuoteAddLiqGet(address, tick0, tick1, amount0, amount1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Estimate the number of ticks you can get by typing LP.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {string} lp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapQuoteRemoveLiqGet(address: string, tick0: string, tick1: string, lp: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20031>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapQuoteRemoveLiqGet(address, tick0, tick1, lp, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary quote swap
         * @param {string} address 
         * @param {string} tickIn Input tick
         * @param {string} tickOut Output tick
         * @param {string} amount The amount of input tick
         * @param {string} exactType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapQuoteSwapGet(address: string, tickIn: string, tickOut: string, amount: string, exactType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20032>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapQuoteSwapGet(address, tickIn, tickOut, amount, exactType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove the liquidity operation
         * @param {Brc20swapRemoveLiqBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapRemoveLiqPost(body: Brc20swapRemoveLiqBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20030>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapRemoveLiqPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get chain history of rollup inscription.
         * @param {number} start 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapRollupHistoryGet(start: number, limit: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20041>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapRollupHistoryGet(start, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Select the tick information that you can use based on the address.
         * @param {string} address 
         * @param {string} [search] Fuzzy matching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapSelectGet(address: string, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20026>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapSelectGet(address, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the history of swap.
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [address] 
         * @param {string} [tick] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapSwapHistoryGet(start: number, limit: number, address?: string, tick?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20040>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapSwapHistoryGet(start, limit, address, tick, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary The swap operation.
         * @param {Brc20swapSwapBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapSwapPost(body: Brc20swapSwapBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20033>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapSwapPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the current system state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapSystemStatusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20044>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapSystemStatusGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the user withdrawal history.
         * @param {string} address 
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [tick] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapWithdrawHistoryGet(address: string, start: number, limit: number, tick?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20045>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapWithdrawHistoryGet(address, start, limit, tick, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the withdrawal progress for the specified ID.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapWithdrawProcessGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20048>>> {
            const localVarAxiosArgs = await BRC20SwapApiAxiosParamCreator(configuration).v1Brc20SwapWithdrawProcessGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BRC20SwapApi - factory interface
 * @export
 */
export const BRC20SwapApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add the liquidity operation.
         * @param {Brc20swapAddLiqBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapAddLiqPost(body: Brc20swapAddLiqBody, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20030>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapAddLiqPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the balance for the specified address and tick.
         * @param {string} address 
         * @param {string} tick 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapBalanceGet(address: string, tick: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20024>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapBalanceGet(address, tick, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Swap's global configuration information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapConfigGet(options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20023>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User signature cancel-withdraw psbt, submit confirmation.
         * @param {Brc20swapConfirmCancelWithdrawBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapConfirmCancelWithdrawPost(body: Brc20swapConfirmCancelWithdrawBody, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20028>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapConfirmCancelWithdrawPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User signature deposit psbt, submit confirmation.
         * @param {Brc20swapConfirmDepositBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapConfirmDepositPost(body: Brc20swapConfirmDepositBody, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20028>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapConfirmDepositPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User signature withdraw psbt, submit confirmation.
         * @param {Brc20swapConfirmWithdrawBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapConfirmWithdrawPost(body: Brc20swapConfirmWithdrawBody, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20028>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapConfirmWithdrawPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a cancel-withdraw psbt to be signed by the user.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapCreateCancelWithdrawGet(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20047>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapCreateCancelWithdrawGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a deposit psbt to be signed by the user.
         * @param {string} inscriptionId 
         * @param {string} pubkey 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapCreateDepositGet(inscriptionId: string, pubkey: string, address: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20043>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapCreateDepositGet(inscriptionId, pubkey, address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a withdraw psbt to be signed by the user.
         * @param {string} pubkey 
         * @param {string} address 
         * @param {string} tick 
         * @param {string} amount 
         * @param {number} ts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapCreateWithdrawGet(pubkey: string, address: string, tick: string, amount: string, ts: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20046>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapCreateWithdrawGet(pubkey, address, tick, amount, ts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deploy the pool operation.
         * @param {Brc20swapDeployPoolBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapDeployPoolPost(body: Brc20swapDeployPoolBody, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20028>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapDeployPoolPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get deposit information for the specified address and tick, including daily limit, dosage, recommended deposit amount, etc.
         * @param {string} address 
         * @param {string} tick 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapDepositInfoGet(address: string, tick: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20025>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapDepositInfoGet(address, tick, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the deposit list for a user.
         * @param {string} address 
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [tick] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapDepositListGet(address: string, start: number, limit: number, tick?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20042>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapDepositListGet(address, start, limit, tick, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the gas consumption records for a user aggregation operation.
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [address] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapGasHistoryGet(start: number, limit: number, address?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20038>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapGasHistoryGet(start, limit, address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the history of a pair addition pool.
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [address] 
         * @param {string} [tick] 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapLiqHistoryGet(start: number, limit: number, address?: string, tick?: string, type?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20039>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapLiqHistoryGet(start, limit, address, tick, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the user pool information for the specified pair.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapMyPoolGet(address: string, tick0: string, tick1: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20036>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapMyPoolGet(address, tick0, tick1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the pool list information by address.
         * @param {string} address 
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [tick] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapMyPoolListGet(address: string, start: number, limit: number, tick?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20035>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapMyPoolListGet(address, start, limit, tick, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary An overview of swap information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapOverviewGet(options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20037>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the pool list information.
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [search] Fuzzy matching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapPoolListGet(start: number, limit: number, search?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20034>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapPoolListGet(start, limit, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /add_liq interface pre-load, get the signature content, gas and byte information.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {string} amount0 Input amount of tick0
         * @param {string} amount1 Input amount of tick1
         * @param {string} lp Expect amount of lp
         * @param {string} slippage 
         * @param {number} ts Timestamp (seconds)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapPreAddLiqGet(address: string, tick0: string, tick1: string, amount0: string, amount1: string, lp: string, slippage: string, ts: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20027>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapPreAddLiqGet(address, tick0, tick1, amount0, amount1, lp, slippage, ts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /deploy_pool interface pre-load, get the signature content, gas and byte information.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {number} ts Timestamp (seconds)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapPreDeployPoolGet(address: string, tick0: string, tick1: string, ts: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20027>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapPreDeployPoolGet(address, tick0, tick1, ts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /remove_liq interface pre-load, get the signature content, gas and byte information.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {string} amount0 Input amount of tick0
         * @param {string} amount1 Input amount of tick1
         * @param {string} lp 
         * @param {string} slippage 
         * @param {number} ts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapPreRemoveLiqGet(address: string, tick0: string, tick1: string, amount0: string, amount1: string, lp: string, slippage: string, ts: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20027>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapPreRemoveLiqGet(address, tick0, tick1, amount0, amount1, lp, slippage, ts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /swap interface pre-load, get the signature content, gas and byte information.
         * @param {string} address 
         * @param {string} tickIn Input tick
         * @param {string} tickOut Output tick
         * @param {string} amountIn The amount of input tick
         * @param {string} amountOut The amount of output tick
         * @param {string} slippage 
         * @param {string} exactType 
         * @param {number} ts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapPreSwapGet(address: string, tickIn: string, tickOut: string, amountIn: string, amountOut: string, slippage: string, exactType: string, ts: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20027>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapPreSwapGet(address, tickIn, tickOut, amountIn, amountOut, slippage, exactType, ts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Based on the pair to get the actual addition ratio, LP number and other information.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {string} [amount0] amount0 and amount1 can only be set individually.
         * @param {string} [amount1] amount0 and amount1 can only be set individually.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapQuoteAddLiqGet(address: string, tick0: string, tick1: string, amount0?: string, amount1?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20029>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapQuoteAddLiqGet(address, tick0, tick1, amount0, amount1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Estimate the number of ticks you can get by typing LP.
         * @param {string} address 
         * @param {string} tick0 
         * @param {string} tick1 
         * @param {string} lp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapQuoteRemoveLiqGet(address: string, tick0: string, tick1: string, lp: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20031>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapQuoteRemoveLiqGet(address, tick0, tick1, lp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary quote swap
         * @param {string} address 
         * @param {string} tickIn Input tick
         * @param {string} tickOut Output tick
         * @param {string} amount The amount of input tick
         * @param {string} exactType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapQuoteSwapGet(address: string, tickIn: string, tickOut: string, amount: string, exactType: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20032>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapQuoteSwapGet(address, tickIn, tickOut, amount, exactType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the liquidity operation
         * @param {Brc20swapRemoveLiqBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapRemoveLiqPost(body: Brc20swapRemoveLiqBody, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20030>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapRemoveLiqPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get chain history of rollup inscription.
         * @param {number} start 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapRollupHistoryGet(start: number, limit: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20041>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapRollupHistoryGet(start, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Select the tick information that you can use based on the address.
         * @param {string} address 
         * @param {string} [search] Fuzzy matching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapSelectGet(address: string, search?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20026>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapSelectGet(address, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the history of swap.
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [address] 
         * @param {string} [tick] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapSwapHistoryGet(start: number, limit: number, address?: string, tick?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20040>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapSwapHistoryGet(start, limit, address, tick, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary The swap operation.
         * @param {Brc20swapSwapBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapSwapPost(body: Brc20swapSwapBody, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20033>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapSwapPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the current system state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapSystemStatusGet(options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20044>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapSystemStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the user withdrawal history.
         * @param {string} address 
         * @param {number} start 
         * @param {number} limit 
         * @param {string} [tick] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapWithdrawHistoryGet(address: string, start: number, limit: number, tick?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20045>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapWithdrawHistoryGet(address, start, limit, tick, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the withdrawal progress for the specified ID.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1Brc20SwapWithdrawProcessGet(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20048>> {
            return BRC20SwapApiFp(configuration).v1Brc20SwapWithdrawProcessGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BRC20SwapApi - object-oriented interface
 * @export
 * @class BRC20SwapApi
 * @extends {BaseAPI}
 */
export class BRC20SwapApi extends BaseAPI {
    /**
     * 
     * @summary Add the liquidity operation.
     * @param {Brc20swapAddLiqBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapAddLiqPost(body: Brc20swapAddLiqBody, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20030>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapAddLiqPost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the balance for the specified address and tick.
     * @param {string} address 
     * @param {string} tick 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapBalanceGet(address: string, tick: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20024>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapBalanceGet(address, tick, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Swap's global configuration information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapConfigGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20023>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapConfigGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary User signature cancel-withdraw psbt, submit confirmation.
     * @param {Brc20swapConfirmCancelWithdrawBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapConfirmCancelWithdrawPost(body: Brc20swapConfirmCancelWithdrawBody, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20028>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapConfirmCancelWithdrawPost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary User signature deposit psbt, submit confirmation.
     * @param {Brc20swapConfirmDepositBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapConfirmDepositPost(body: Brc20swapConfirmDepositBody, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20028>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapConfirmDepositPost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary User signature withdraw psbt, submit confirmation.
     * @param {Brc20swapConfirmWithdrawBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapConfirmWithdrawPost(body: Brc20swapConfirmWithdrawBody, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20028>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapConfirmWithdrawPost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a cancel-withdraw psbt to be signed by the user.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapCreateCancelWithdrawGet(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20047>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapCreateCancelWithdrawGet(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a deposit psbt to be signed by the user.
     * @param {string} inscriptionId 
     * @param {string} pubkey 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapCreateDepositGet(inscriptionId: string, pubkey: string, address: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20043>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapCreateDepositGet(inscriptionId, pubkey, address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create a withdraw psbt to be signed by the user.
     * @param {string} pubkey 
     * @param {string} address 
     * @param {string} tick 
     * @param {string} amount 
     * @param {number} ts 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapCreateWithdrawGet(pubkey: string, address: string, tick: string, amount: string, ts: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20046>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapCreateWithdrawGet(pubkey, address, tick, amount, ts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Deploy the pool operation.
     * @param {Brc20swapDeployPoolBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapDeployPoolPost(body: Brc20swapDeployPoolBody, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20028>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapDeployPoolPost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get deposit information for the specified address and tick, including daily limit, dosage, recommended deposit amount, etc.
     * @param {string} address 
     * @param {string} tick 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapDepositInfoGet(address: string, tick: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20025>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapDepositInfoGet(address, tick, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the deposit list for a user.
     * @param {string} address 
     * @param {number} start 
     * @param {number} limit 
     * @param {string} [tick] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapDepositListGet(address: string, start: number, limit: number, tick?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20042>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapDepositListGet(address, start, limit, tick, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the gas consumption records for a user aggregation operation.
     * @param {number} start 
     * @param {number} limit 
     * @param {string} [address] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapGasHistoryGet(start: number, limit: number, address?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20038>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapGasHistoryGet(start, limit, address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the history of a pair addition pool.
     * @param {number} start 
     * @param {number} limit 
     * @param {string} [address] 
     * @param {string} [tick] 
     * @param {string} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapLiqHistoryGet(start: number, limit: number, address?: string, tick?: string, type?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20039>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapLiqHistoryGet(start, limit, address, tick, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the user pool information for the specified pair.
     * @param {string} address 
     * @param {string} tick0 
     * @param {string} tick1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapMyPoolGet(address: string, tick0: string, tick1: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20036>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapMyPoolGet(address, tick0, tick1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the pool list information by address.
     * @param {string} address 
     * @param {number} start 
     * @param {number} limit 
     * @param {string} [tick] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapMyPoolListGet(address: string, start: number, limit: number, tick?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20035>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapMyPoolListGet(address, start, limit, tick, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary An overview of swap information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapOverviewGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20037>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the pool list information.
     * @param {number} start 
     * @param {number} limit 
     * @param {string} [search] Fuzzy matching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapPoolListGet(start: number, limit: number, search?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20034>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapPoolListGet(start, limit, search, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary /add_liq interface pre-load, get the signature content, gas and byte information.
     * @param {string} address 
     * @param {string} tick0 
     * @param {string} tick1 
     * @param {string} amount0 Input amount of tick0
     * @param {string} amount1 Input amount of tick1
     * @param {string} lp Expect amount of lp
     * @param {string} slippage 
     * @param {number} ts Timestamp (seconds)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapPreAddLiqGet(address: string, tick0: string, tick1: string, amount0: string, amount1: string, lp: string, slippage: string, ts: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20027>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapPreAddLiqGet(address, tick0, tick1, amount0, amount1, lp, slippage, ts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary /deploy_pool interface pre-load, get the signature content, gas and byte information.
     * @param {string} address 
     * @param {string} tick0 
     * @param {string} tick1 
     * @param {number} ts Timestamp (seconds)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapPreDeployPoolGet(address: string, tick0: string, tick1: string, ts: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20027>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapPreDeployPoolGet(address, tick0, tick1, ts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary /remove_liq interface pre-load, get the signature content, gas and byte information.
     * @param {string} address 
     * @param {string} tick0 
     * @param {string} tick1 
     * @param {string} amount0 Input amount of tick0
     * @param {string} amount1 Input amount of tick1
     * @param {string} lp 
     * @param {string} slippage 
     * @param {number} ts 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapPreRemoveLiqGet(address: string, tick0: string, tick1: string, amount0: string, amount1: string, lp: string, slippage: string, ts: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20027>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapPreRemoveLiqGet(address, tick0, tick1, amount0, amount1, lp, slippage, ts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary /swap interface pre-load, get the signature content, gas and byte information.
     * @param {string} address 
     * @param {string} tickIn Input tick
     * @param {string} tickOut Output tick
     * @param {string} amountIn The amount of input tick
     * @param {string} amountOut The amount of output tick
     * @param {string} slippage 
     * @param {string} exactType 
     * @param {number} ts 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapPreSwapGet(address: string, tickIn: string, tickOut: string, amountIn: string, amountOut: string, slippage: string, exactType: string, ts: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20027>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapPreSwapGet(address, tickIn, tickOut, amountIn, amountOut, slippage, exactType, ts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Based on the pair to get the actual addition ratio, LP number and other information.
     * @param {string} address 
     * @param {string} tick0 
     * @param {string} tick1 
     * @param {string} [amount0] amount0 and amount1 can only be set individually.
     * @param {string} [amount1] amount0 and amount1 can only be set individually.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapQuoteAddLiqGet(address: string, tick0: string, tick1: string, amount0?: string, amount1?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20029>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapQuoteAddLiqGet(address, tick0, tick1, amount0, amount1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Estimate the number of ticks you can get by typing LP.
     * @param {string} address 
     * @param {string} tick0 
     * @param {string} tick1 
     * @param {string} lp 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapQuoteRemoveLiqGet(address: string, tick0: string, tick1: string, lp: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20031>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapQuoteRemoveLiqGet(address, tick0, tick1, lp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary quote swap
     * @param {string} address 
     * @param {string} tickIn Input tick
     * @param {string} tickOut Output tick
     * @param {string} amount The amount of input tick
     * @param {string} exactType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapQuoteSwapGet(address: string, tickIn: string, tickOut: string, amount: string, exactType: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20032>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapQuoteSwapGet(address, tickIn, tickOut, amount, exactType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Remove the liquidity operation
     * @param {Brc20swapRemoveLiqBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapRemoveLiqPost(body: Brc20swapRemoveLiqBody, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20030>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapRemoveLiqPost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get chain history of rollup inscription.
     * @param {number} start 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapRollupHistoryGet(start: number, limit: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20041>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapRollupHistoryGet(start, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Select the tick information that you can use based on the address.
     * @param {string} address 
     * @param {string} [search] Fuzzy matching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapSelectGet(address: string, search?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20026>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapSelectGet(address, search, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the history of swap.
     * @param {number} start 
     * @param {number} limit 
     * @param {string} [address] 
     * @param {string} [tick] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapSwapHistoryGet(start: number, limit: number, address?: string, tick?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20040>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapSwapHistoryGet(start, limit, address, tick, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary The swap operation.
     * @param {Brc20swapSwapBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapSwapPost(body: Brc20swapSwapBody, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20033>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapSwapPost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the current system state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapSystemStatusGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20044>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapSystemStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the user withdrawal history.
     * @param {string} address 
     * @param {number} start 
     * @param {number} limit 
     * @param {string} [tick] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapWithdrawHistoryGet(address: string, start: number, limit: number, tick?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20045>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapWithdrawHistoryGet(address, start, limit, tick, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Gets the withdrawal progress for the specified ID.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BRC20SwapApi
     */
    public async v1Brc20SwapWithdrawProcessGet(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20048>> {
        return BRC20SwapApiFp(this.configuration).v1Brc20SwapWithdrawProcessGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}
